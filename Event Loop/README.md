# JS Event Loop এর ছোট গল্প

জাভাস্ক্রিপ্ট এর ইভেন্টলুপ বুঝার আগে আমাদের আগে জানতে হবে জাভাস্ক্রিপ্ট কিভাবে রান হয় বা কিভাবে মেশিন কোডে রুপান্তরিত হয়। 

জাভাস্ক্রিপ্ট কোড কম্পাইল বা মেশিন কোডে রুপান্তর হওয়ার জন্য ইঞ্জিন এর প্রোয়োজন । সেই ইঞ্জিনের ভিতরে কিছু জিনিস থাকে যেমনঃ Heap, Call stack , Worker API (যেমন ব্রাউজার এর জন্য web api আর নোড জে এস এর জন্য  তাদের নিজেস্ব API ) এবং  বিভিন্ন Queue থাকে এবং একটা Event Loop থাকে। এখন উপরের নতুন শব্দগুলোর সাথে আরেকটু পরিচয় হওয়া যাক ! 

### Heap কি?

Heap মেমোরি ম্যানেজমেন্ট এর জন্য ব্যবহার করা হয়। এটি একটি আনস্ট্রাকচার  মেমোরি ব্লক এখানে আমাদের কোডের বিভিন্ন মেমোরি এলোকেশন এর কাজগুলো করা হয় যা এলোমেলো আকারে থাকে, তাই এটিকে আনস্ট্রাকচার  মেমোরি ব্লক বলা হয় ।

আর  মেমরি এলোকেশন বলতে বুঝায় আমাদের কোড রান করার সময় ডাটা সংরক্ষন করার জন্য কম্পিউটার এর মেমোরির (RAM) এর নির্দিষ্ট জায়গা দখল  করাকে বুঝায়। 

### Call Stack কী?

**Call Stack** হল **JavaScript Execution Context** পরিচালনার জন্য একটি মেকানিজম যেখানে আমাদের সিনক্রোনাস কোডগুলো লাইন বাই লাইন রান  করে থাকে। এটি একটি **LIFO (Last In, First Out)** স্ট্রাকচার, অর্থাৎ **শেষে যেটা আসে, সেটাই প্রথমে চলে যায়**।

### Worker API কী?

Worker API হলো JavaScript-এর একটি ফিচার যা **ব্যাকগ্রাউন্ড থ্রেড** তৈরি করে এবং ভারী কাজ (যেমন  বড় ডাটা প্রসেসিং, সিপিউ ইন্টেন্সিভ কাজ ) মেইন থ্রেড ব্লক না করেই চালাতে সাহায্য করে। কারন আমরা জানি জাভাস্ক্রিপ্ট Single-threaded হয়।  অর্থাৎ এটি একসাথে একটাই কাজ করতে পারে। যদি বড় কোনো কাজ করা হয়, তাহলে **UI ব্লক হয়ে যেতে পারে**। কিন্তু **Web Worker ব্যবহার করলে ব্যাকগ্রাউন্ডে কাজ করা সম্ভব হয়** এবং UI আটকে থাকে না।

### **Queue কী?**

Queue হলো **একটি ডাটা স্ট্রাকচার**, যেখানে **"First In, First Out (FIFO)"** পদ্ধতিতে ডাটা সংরক্ষণ এবং ব্যবস্থাপনা করা হয়। অর্থাৎ যখন worker api তে কোনো কাজ সম্পন্ন হয় তখন সেটি এই queue এর ভিতরে প্রবেশ করে। 

### **Event Loop কী?**

Event Loop হলো **JavaScript-এর প্রধান মেকানিজম** , যা **অ্যাসিনক্রোনাস (Asynchronous) কাজ গুলো পরিচালনা করে** আর এর কারনে জাভাস্ক্রিপ্ট সিংগেল থ্রেডেড প্রোগ্রামিং ল্যাঙ্গুয়েজ হয়া সত্ত্বেও non blocking ভাবে কোড রান করতে পারে। 

**ইভেন্ট লুপের কাজের ধাপ (Step-by-Step)**

✅ ধাপ 1: আমাদের জাভাস্ক্রিপ্ট কোড Call Stackএ এক্সিকিউট হয়।

✅ ধাপ 2: যদি কোনো Async ফাংশন যেমনঃ (setTimeout, fetch, Promise) থাকে, তাহলে তা Web API-তে পাঠানো হয়।

✅ ধাপ 3: Async কাজ শেষ হলে CallBack Queue-তে পাঠানো হয়।

✅ ধাপ 4: Call Stack ফাঁকা হলে ইভেন্ট লুপ Callback Queue থেকে কলব্যাক এনে এক্সিকিউট করে।

### কোড কম্পাইল এর প্রসেসিং সম্পর্কে জানা যাকঃ

যখন আমাদের কোড ইঞ্জিনের কাছে  যায় তখন জাভাস্ক্রিপ্ট ইঞ্জিন  একপলক পুরো কোডকে দেখে নেয় এবং যদি কোথায় মেমোরি এলোকেশন এর প্রয়োজন হয় তখন তা Heap এর মধ্যে তা করে নেয়। পুরো কোডের মেমোরি এলোকেশন এর কাজ শেষ হয়ে গেলে তখন কোড রান করার জন্য রেডি হয়। তখন লাইন বাই লাইন কোড রান হয় । রান হওয়ার সময় যখন আমদের কোড call stack এ যায় তখন যদি সেই কোড সিনক্রোনাস হয় তখন সেটি সাথে সাথে এক্সিকিউট হয়ে যায়। আর যদি এসিনক্রোনাস কোড হয় তখন সেই কোডটি call stack থেকে পপ আউট হয়ে web api তে যাবে এবং সেখানে সেই কোড এক্সিকিউট হবে। web api তে যদি সেই কোড এক্সিকিউট শেষ হয়ে যায় তখন সেটি call back queue তে প্রবেশ করে। তখন event loop দেখবে যে উপরের call stack খালি আছে কি না ? যদি খালি থাকে তাহলে call back  queue তে থাকা call back ফাংশনটিকে ইভেন্ট লুপ  call stack এ পাঠিয়ে দিবে। তখন call stack সেই call back ফাংশনটি এক্সিকিউট বা রান হবে।  জাভাস্ক্রিপ্ট কোডের ইঞ্জিন এর ভিজিওয়ালাইজেশন অনেকটাই এমনঃ 

![image.png](attachment:2cfa95b4-363e-47d4-a2f8-b999f5d8e452:image.png)

এখন কোডের মধ্যমে উদাহারণ দেখা যাকঃ 

```jsx
console.log("Start");

setTimeout(() => {
    console.log("Inside setTimeout");
}, 0);

console.log("End");

// output
 Start  
 End  
 Inside setTimeout  
```

### **ব্যাখ্যা:**

1️⃣ `console.log("Start")` → Call Stack-এ যাবে এবং প্রিন্ট হবে।

2️⃣ `setTimeout(..., 0)` → এটি **Web API-তে পাঠানো হবে**, এবং 0ms পরে **Callback Queue-তে পাঠানো হবে**।

3️⃣ `console.log("End")` → Call Stack-এ এক্সিকিউট হয়ে প্রিন্ট হবে।

4️⃣ **Call Stack ফাঁকা হলে** Event Loop **Callback Queue থেকে setTimeout-এর ফাংশন এনে এক্সিকিউট করবে**।

আর এই কারনে `Inside setTimeout` সবার শেষে প্রিন্ট হবে। 

ওকে, ইভেন্ট লুপ যদি এখন কিছুটা জেনে থাকো তাইলে আমরা আরেকটা ছোট জিনিস জেনে  রাখি সেটা হচ্ছে,  Queue কয়েক প্রকার আছে যেমনঃ Callback Queue, Microtask Queue 

 setTimeout, setInterval, DOM Events এগুলো ওয়েব এপিআই তে এক্সিকিউট হওয়ার পরে Callback Queue তে প্রবেশ করে আর Promises, MutationObserver এগুলো Microtask Queue তে প্রবেশ করে। আর ইভেন্ট লুপের কাছে Microtask Queue এটি Callback Queue এর থেকে বেশি গুরুত্ব পায় তাই ইভেন্ট লুপ আগে Microtask Queue এর প্রমিজ গুলো এক্সিকিউট করে তারপর  Callback Queue এর কোডগুলো এক্সিকিউট করে। যেমনঃ

```jsx

console.log("Start");

setTimeout(() => {
    console.log("Inside setTimeout");
}, 0);

Promise.resolve().then(() => {
    console.log("Inside Promise");
});

console.log("End");

// output 
Start  
End  
Inside Promise  
Inside setTimeout 
```

### **ব্যাখ্যা:**

✅ `console.log("Start")` এক্সিকিউট হয়ে **প্রথমে প্রিন্ট** হবে।

✅ `setTimeout(..., 0)` → Web API-তে যাবে এবং পরে **Callback Queue-তে জমা হবে**।

✅ `Promise.resolve().then(...)` → **Microtask Queue-তে যাবে (Priority High!)**।

✅ `console.log("End")` **প্রিন্ট হবে**।

✅ **Call Stack ফাঁকা হলে, Microtask Queue থেকে "Inside Promise" প্রিন্ট হবে**।

✅ **তারপর Callback Queue থেকে "Inside setTimeout" প্রিন্ট হবে**।

আর এই ছিলো ইভেন্টলুপের ছোট গল্প ☺️