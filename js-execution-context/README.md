# Execution Context in JS

### **How to js sees your code:**

যখন জাভাস্ক্রিপ্ট কোড প্রথমে পায় তখন সেই কোড কে টুকরো টুকরো করে ভেঙ্গে নেয়। আর এই প্রসেসকে বলা হয় টোকেনাইজেশন।  আর কোড ভাঙ্গার পর প্রত্যেকটা টুকরো কে বলা হয় একেকটা টোকেন। 

যেমনঃ 

![image.png](attachment:4a991754-1a63-4133-90be-2f1b11aba6ca:image.png)

এই ভাবে কোড কে ভেঙ্গে ফেলা হয়। আর এই প্রসেস এর নাম টোকেনাইজেশন। 

তারপর এই টোকেন গুলো নিয়ে একটা ট্রি তৈরি করা হয়। যার নাম AST(Abstract Syntax Tree) এই AST কে জাভাস্ক্রিপট ইনপুট হিসেবে নিয়ে সেখান থেকে যেটা প্রডিউস করে সেটা হচ্ছে একটা মেশিন কোড যেটা পরে আমাদের ব্রাউজারে গিয়ে রান হতে পারে। অর্থাৎ কোড রান হওয়ার প্রসেসটা হচ্ছে :- 

 **source code → AST → Machine Code → code output**

### **What is Execution Context:**

আমাদের প্রতিটা কোড এর জন্য জাভাস্ক্রিপট লেক্সিকাল পজিশন বা ইনভায়োরমেন্ট  তৈরি করে। লেক্সিকাল ইনভায়োরমেন্ট বলতে বুঝায় কোনো কোড এর পজিশন অর্থাৎ, কোন কোড কোন  জায়গায় থেকে শুরূ হয়েছে এবং কোন জায়গায় তা শেষ হয়েছে। আর সেই পজিশন কে বলা হয় লেক্সিকাল ইনভায়োরমেন্ট।  তাই আমাদের কোডে অনেক কোডের জন্য অনেক লেক্সিকাল ইনভায়োরমেন্ট থাকতে পারে । 

> ***প্রতিটা জাভাস্ক্রিপ্ট  কোড এক্সিকিউট করার জন্য  যা যা দরকার সেই জিনিসগুলো কে বলা হয় এক্সিকিউশন কন্টেক্স ।***
> 

### **Explanation of js Execution Context:**

যখন জাভাস্ক্রিপট কোড ফার্স্ট টাইম রান করে তখন জাভাস্ক্রিপট বাই ডিফল্ট একটা এক্সিকিউশন কন্টেক্স তৈরি করে যার নাম Global Execution Context(GEC).  গ্লোবাল মানে হলো গ্লোবাল স্কোপ । অর্থাৎ, ফাংশন এবং যে কোনো ব্লোক এর বাইরে আমাদের কোডে যা থাকে সেটাই গ্লোবাল স্কোপ।  

### Global Execution Context(GEC)

যখন গ্লোবাল এক্সিকিউশন কন্টেক্স তৈরি হয়, তখন global এক্সিকিউশন কন্টেক্সে দুটি ফেইজ তৈরি হয় creation phase & execution phase.  

**Creation Phase** - 

- এ  আমরা সে দুইটা জিনিস পাই **globa বা window** অব্জেক্ট এবং **this** কী ওয়ার্ড। গ্লোবাল এক্সিকিউশন কন্টেক্সে this  **globa বা window** অব্জেক্টকে পয়েন্ট করে রাখে। তাই যদি আমরা this === window করি তখন ture পাবো।
- এরপর যদি আমাদের কোডে গ্লোবাল স্কোপে কোনো ভ্যারিয়েবল বা ফাংশন ডিক্লারেশন থাকে তখন তার জন্য আগে মেমরি  এলোকেট করবে।
- তারপর var দিয়ে ডিকলার করা ভেরিয়েবল কে undefined দিয়ে ইনিশিয়ালাইজড করবে। এরপর ফাংশনএর ডেফিনেশন এর কোডটুকু মেমরিতে কোনো একটা জায়গায় রেখে দিবে।

![image.png](attachment:e1d9f869-1b93-4fce-8566-cc1e21bcbdc5:image.png)

 Execution Context: সকল ভেরিয়েবল এবং ফাংশন ডিক্লারেশন এর মেমরি এলোকেশন এর কাজ শেষ হয়ে গেলে তখন এক্সিকিউশন কন্টেক্স তৈরি হয়। তখন লাইন বাই লাইন কোড এক্সিকিউট করে। 

- উপরের কোডের প্রেক্ষিতে শুধু name ভেরিয়েবল এর ভ্যালু এসাইন হবে। আর নিচের লাইনে যেহেতু ফাংশন ডিক্লারেশন তখন সেটা গ্লোবাল এক্সিকিউশনে এক্সিকিউট হবে না। কিন্তু এর পরের লাইনে যেহেতু ফাংশনকে কল করা হয়েছে তাই এর পরের লাইন এক্সিকিউট হবে। যেহেতু এটা ফাংশন তাই নতুন আরেকটা এক্সিকিউশন কন্টেক্স তৈরি হবে । সেটি হলো function execution context

![image.png](attachment:eadb0abb-33d4-4d40-994e-8f1f4fcc9cdd:image.png)

Function Execution Context: এরও ২ টি ফেইজ থাকে creation ফেইজ এবং execution ফেইজ । ফাংশন এক্সিকিউশন ফেইজের মধ্যে ফাংশন ব্লোক এর ভিতরে যেই ভ্যারিয়েবল থাকে তা মেমোরিতে এলোকেট করা হয় এরপর var দিয়ে ডিক্লার করা ভেরিয়েবলগুলোকে undefined দিয়ে ইনিশিয়ালাইজ করে । এর পর এক্সিকিউশন ফেইজে এসে সেগুলো কে এক্সিকিউট করে। 

এখন আমরা একটা উদাহারন দিয়ে দেখিঃ 

![image.png](attachment:ca28b549-779a-46b2-b22f-cc26c1342391:image.png)

 জাভাস্ক্রিপ্টে কোড এক্সিকিউশন এর জন্য মেমরি লেভেলে  ২টা জিনিস ব্যবহার করা হয় একটা হচ্ছে যেটাকে বলা হয় call stack এবং অন্যটি হচ্ছে heap । 

**Stack** হলো একটি **Memory Structure**, যেখানে **Primitive Data Types** (যেমনঃ `number`, `string`, `boolean`, ইত্যাদি) সংরক্ষিত হয়। এটি **LIFO (Last In, First Out)** পদ্ধতিতে কাজ করে।

heap : heap হচ্ছে ডিস্ক্রিট মেমরি স্ট্রাকচার যেখানে অবজেক্ট এবং ডাটা সংরক্ষণ করা হয় এবং ডাটা গুলো ছড়িয়ে ছিটিয়ে থাকে।  এটি **Garbage Collection (GC)**-এর মাধ্যমে পরিচালিত হয়, যা অব্যবহৃত মেমোরি ইন্টিলিজেন্ট ভাবে মুক্ত করে।

v8 ইঞ্জিন JIT  (Just In time) কম্পাইল্ড করে । অর্থাৎ, ইন্টারপ্রেটেশন এবং কম্পাইল্ড এর সংশমিশ্রনে কাজ করে।


Orginal Note : (https://grand-relative-744.notion.site/Execution-Context-in-JS-18e3fc908e76804faeb8e19e5f9940da)